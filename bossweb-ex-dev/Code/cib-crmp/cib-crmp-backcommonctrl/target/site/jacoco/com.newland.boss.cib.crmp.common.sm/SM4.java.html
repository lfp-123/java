<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SM4.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cib-crmp-backcommonctrl</a> &gt; <a href="index.source.html" class="el_package">com.newland.boss.cib.crmp.common.sm</a> &gt; <span class="el_source">SM4.java</span></div><h1>SM4.java</h1><pre class="source lang-java linenums">package com.newland.boss.cib.crmp.common.sm;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

/**
 * sm4实现
 */
<span class="fc" id="L10">public class SM4 {</span>
    public static final int SM4_ENCRYPT = 1;

    public static final int SM4_DECRYPT = 0;

    private long getUlongBe(byte[] b, int i) {
<span class="fc" id="L16">        return (long) (b[i] &amp; 0xff) &lt;&lt; 24 | (long) ((b[i + 1] &amp; 0xff) &lt;&lt; 16) | (long) ((b[i + 2] &amp; 0xff) &lt;&lt; 8) | (long) (b[i + 3] &amp; 0xff) &amp; 0xffffffffL;</span>
    }

    private void putUlongBe(long n, byte[] b, int i) {
<span class="fc" id="L20">        b[i] = (byte) (int) (0xFF &amp; n &gt;&gt; 24);</span>
<span class="fc" id="L21">        b[i + 1] = (byte) (int) (0xFF &amp; n &gt;&gt; 16);</span>
<span class="fc" id="L22">        b[i + 2] = (byte) (int) (0xFF &amp; n &gt;&gt; 8);</span>
<span class="fc" id="L23">        b[i + 3] = (byte) (int) (0xFF &amp; n);</span>
<span class="fc" id="L24">    }</span>

    private long shl(long x, int n) {
<span class="fc" id="L27">        return (x &amp; 0xFFFFFFFF) &lt;&lt; n;</span>
    }

    private long rotl(long x, int n) {
<span class="fc" id="L31">        return shl(x, n) | x &gt;&gt; (32 - n);</span>
    }

    private void swap(long[] sk, int i) {
<span class="fc" id="L35">        long t = sk[i];</span>
<span class="fc" id="L36">        sk[i] = sk[(31 - i)];</span>
<span class="fc" id="L37">        sk[(31 - i)] = t;</span>
<span class="fc" id="L38">    }</span>

<span class="fc" id="L40">    protected static final byte[] SBOX_TABLE = {(byte) 0xd6, (byte) 0x90, (byte) 0xe9, (byte) 0xfe,</span>
            (byte) 0xcc, (byte) 0xe1, 0x3d, (byte) 0xb7, 0x16, (byte) 0xb6,
            0x14, (byte) 0xc2, 0x28, (byte) 0xfb, 0x2c, 0x05, 0x2b, 0x67,
            (byte) 0x9a, 0x76, 0x2a, (byte) 0xbe, 0x04, (byte) 0xc3,
            (byte) 0xaa, 0x44, 0x13, 0x26, 0x49, (byte) 0x86, 0x06,
            (byte) 0x99, (byte) 0x9c, 0x42, 0x50, (byte) 0xf4, (byte) 0x91,
            (byte) 0xef, (byte) 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43,
            (byte) 0xed, (byte) 0xcf, (byte) 0xac, 0x62, (byte) 0xe4,
            (byte) 0xb3, 0x1c, (byte) 0xa9, (byte) 0xc9, 0x08, (byte) 0xe8,
            (byte) 0x95, (byte) 0x80, (byte) 0xdf, (byte) 0x94, (byte) 0xfa,
            0x75, (byte) 0x8f, 0x3f, (byte) 0xa6, 0x47, 0x07, (byte) 0xa7,
            (byte) 0xfc, (byte) 0xf3, 0x73, 0x17, (byte) 0xba, (byte) 0x83,
            0x59, 0x3c, 0x19, (byte) 0xe6, (byte) 0x85, 0x4f, (byte) 0xa8,
            0x68, 0x6b, (byte) 0x81, (byte) 0xb2, 0x71, 0x64, (byte) 0xda,
            (byte) 0x8b, (byte) 0xf8, (byte) 0xeb, 0x0f, 0x4b, 0x70, 0x56,
            (byte) 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, (byte) 0xd1,
            (byte) 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, (byte) 0x87,
            (byte) 0xd4, 0x00, 0x46, 0x57, (byte) 0x9f, (byte) 0xd3, 0x27,
            0x52, 0x4c, 0x36, 0x02, (byte) 0xe7, (byte) 0xa0, (byte) 0xc4,
            (byte) 0xc8, (byte) 0x9e, (byte) 0xea, (byte) 0xbf, (byte) 0x8a,
            (byte) 0xd2, 0x40, (byte) 0xc7, 0x38, (byte) 0xb5, (byte) 0xa3,
            (byte) 0xf7, (byte) 0xf2, (byte) 0xce, (byte) 0xf9, 0x61, 0x15,
            (byte) 0xa1, (byte) 0xe0, (byte) 0xae, 0x5d, (byte) 0xa4,
            (byte) 0x9b, 0x34, 0x1a, 0x55, (byte) 0xad, (byte) 0x93, 0x32,
            0x30, (byte) 0xf5, (byte) 0x8c, (byte) 0xb1, (byte) 0xe3, 0x1d,
            (byte) 0xf6, (byte) 0xe2, 0x2e, (byte) 0x82, 0x66, (byte) 0xca,
            0x60, (byte) 0xc0, 0x29, 0x23, (byte) 0xab, 0x0d, 0x53, 0x4e, 0x6f,
            (byte) 0xd5, (byte) 0xdb, 0x37, 0x45, (byte) 0xde, (byte) 0xfd,
            (byte) 0x8e, 0x2f, 0x03, (byte) 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b,
            0x51, (byte) 0x8d, 0x1b, (byte) 0xaf, (byte) 0x92, (byte) 0xbb,
            (byte) 0xdd, (byte) 0xbc, 0x7f, 0x11, (byte) 0xd9, 0x5c, 0x41,
            0x1f, 0x10, 0x5a, (byte) 0xd8, 0x0a, (byte) 0xc1, 0x31,
            (byte) 0x88, (byte) 0xa5, (byte) 0xcd, 0x7b, (byte) 0xbd, 0x2d,
            0x74, (byte) 0xd0, 0x12, (byte) 0xb8, (byte) 0xe5, (byte) 0xb4,
            (byte) 0xb0, (byte) 0x89, 0x69, (byte) 0x97, 0x4a, 0x0c,
            (byte) 0x96, 0x77, 0x7e, 0x65, (byte) 0xb9, (byte) 0xf1, 0x09,
            (byte) 0xc5, 0x6e, (byte) 0xc6, (byte) 0x84, 0x18, (byte) 0xf0,
            0x7d, (byte) 0xec, 0x3a, (byte) 0xdc, 0x4d, 0x20, 0x79,
            (byte) 0xee, 0x5f, 0x3e, (byte) 0xd7, (byte) 0xcb, 0x39, 0x48};

<span class="fc" id="L80">    protected static final int[] FK = {0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};</span>

<span class="fc" id="L82">    protected static final int[] CK = {0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,</span>
            0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
            0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
            0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
            0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
            0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
            0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
            0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279};

    private byte sm4Sbox(byte inch) {
<span class="fc" id="L92">        int i = inch &amp; 0xFF;</span>
<span class="fc" id="L93">        return SBOX_TABLE[i];</span>
    }

    private long sm4Lt(long ka) {
        long bb;
        long c;
<span class="fc" id="L99">        byte[] a = new byte[4];</span>
<span class="fc" id="L100">        byte[] b = new byte[4];</span>
<span class="fc" id="L101">        putUlongBe(ka, a, 0);</span>
<span class="fc" id="L102">        b[0] = sm4Sbox(a[0]);</span>
<span class="fc" id="L103">        b[1] = sm4Sbox(a[1]);</span>
<span class="fc" id="L104">        b[2] = sm4Sbox(a[2]);</span>
<span class="fc" id="L105">        b[3] = sm4Sbox(a[3]);</span>
<span class="fc" id="L106">        bb = getUlongBe(b, 0);</span>
<span class="fc" id="L107">        c = bb ^ rotl(bb, 2) ^ rotl(bb, 10) ^ rotl(bb, 18) ^ rotl(bb, 24);</span>
<span class="fc" id="L108">        return c;</span>
    }

    private long sm4F(long x0, long x1, long x2, long x3, long rk) {
<span class="fc" id="L112">        return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);</span>
    }

    private long sm4CalciRK(long ka) {
        long bb;
        long rk;
<span class="fc" id="L118">        byte[] a = new byte[4];</span>
<span class="fc" id="L119">        byte[] b = new byte[4];</span>
<span class="fc" id="L120">        putUlongBe(ka, a, 0);</span>
<span class="fc" id="L121">        b[0] = sm4Sbox(a[0]);</span>
<span class="fc" id="L122">        b[1] = sm4Sbox(a[1]);</span>
<span class="fc" id="L123">        b[2] = sm4Sbox(a[2]);</span>
<span class="fc" id="L124">        b[3] = sm4Sbox(a[3]);</span>
<span class="fc" id="L125">        bb = getUlongBe(b, 0);</span>
<span class="fc" id="L126">        rk = bb ^ rotl(bb, 13) ^ rotl(bb, 23);</span>
<span class="fc" id="L127">        return rk;</span>
    }

    private void sm4Setkey(long[] sk, byte[] key) {
<span class="fc" id="L131">        long[] mk = new long[4];</span>
<span class="fc" id="L132">        long[] k = new long[36];</span>
<span class="fc" id="L133">        int i = 0;</span>
<span class="fc" id="L134">        mk[0] = getUlongBe(key, 0);</span>
<span class="fc" id="L135">        mk[1] = getUlongBe(key, 4);</span>
<span class="fc" id="L136">        mk[2] = getUlongBe(key, 8);</span>
<span class="fc" id="L137">        mk[3] = getUlongBe(key, 12);</span>
<span class="fc" id="L138">        k[0] = mk[0] ^ (long) FK[0];</span>
<span class="fc" id="L139">        k[1] = mk[1] ^ (long) FK[1];</span>
<span class="fc" id="L140">        k[2] = mk[2] ^ (long) FK[2];</span>
<span class="fc" id="L141">        k[3] = mk[3] ^ (long) FK[3];</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (; i &lt; 32; i++) {</span>
<span class="fc" id="L143">            k[(i + 4)] = (k[i] ^ sm4CalciRK(k[(i + 1)] ^ k[(i + 2)] ^ k[(i + 3)] ^ (long) CK[i]));</span>
<span class="fc" id="L144">            sk[i] = k[(i + 4)];</span>
        }
<span class="fc" id="L146">    }</span>

    private void sm4OneRound(long[] sk, byte[] input, byte[] output) {
<span class="fc" id="L149">        int i = 0;</span>
<span class="fc" id="L150">        long[] ulbuf = new long[36];</span>
<span class="fc" id="L151">        ulbuf[0] = getUlongBe(input, 0);</span>
<span class="fc" id="L152">        ulbuf[1] = getUlongBe(input, 4);</span>
<span class="fc" id="L153">        ulbuf[2] = getUlongBe(input, 8);</span>
<span class="fc" id="L154">        ulbuf[3] = getUlongBe(input, 12);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        while (i &lt; 32) {</span>
<span class="fc" id="L156">            ulbuf[(i + 4)] = sm4F(ulbuf[i], ulbuf[(i + 1)], ulbuf[(i + 2)], ulbuf[(i + 3)], sk[i]);</span>
<span class="fc" id="L157">            i++;</span>
        }
<span class="fc" id="L159">        putUlongBe(ulbuf[35], output, 0);</span>
<span class="fc" id="L160">        putUlongBe(ulbuf[34], output, 4);</span>
<span class="fc" id="L161">        putUlongBe(ulbuf[33], output, 8);</span>
<span class="fc" id="L162">        putUlongBe(ulbuf[32], output, 12);</span>
<span class="fc" id="L163">    }</span>

    private byte[] padding(byte[] input, int mode) {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L167">            return new byte[0];</span>
        }

        byte[] ret;
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (mode == SM4_ENCRYPT) {</span>
<span class="fc" id="L172">            int p = 16 - input.length % 16;</span>
<span class="fc" id="L173">            ret = new byte[input.length + p];</span>
<span class="fc" id="L174">            System.arraycopy(input, 0, ret, 0, input.length);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (int i = 0; i &lt; p; i++) {</span>
<span class="fc" id="L176">                ret[input.length + i] = (byte) p;</span>
            }
<span class="fc" id="L178">        } else {</span>
<span class="fc" id="L179">            int p = input[input.length - 1];</span>
<span class="fc" id="L180">            ret = new byte[input.length - p];</span>
<span class="fc" id="L181">            System.arraycopy(input, 0, ret, 0, input.length - p);</span>
        }
<span class="fc" id="L183">        return ret;</span>
    }

    public void sm4SetkeyEnc(SM4Context ctx, byte[] key) throws SM4Exception {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L188">            throw new SM4Exception(&quot;ctx is null!&quot;);</span>
        }

<span class="pc bpc" id="L191" title="2 of 4 branches missed.">        if (key == null || key.length != 16) {</span>
<span class="nc" id="L192">            throw new SM4Exception(&quot;key error!&quot;);</span>
        }

<span class="fc" id="L195">        ctx.setMode(SM4_ENCRYPT);</span>
<span class="fc" id="L196">        sm4Setkey(ctx.getSk(), key);</span>
<span class="fc" id="L197">    }</span>

    public void sm4SetkeyDec(SM4Context ctx, byte[] key) throws SM4Exception {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L201">            throw new SM4Exception(&quot;ctx is null!&quot;);</span>
        }

<span class="pc bpc" id="L204" title="2 of 4 branches missed.">        if (key == null || key.length != 16) {</span>
<span class="nc" id="L205">            throw new SM4Exception(&quot;key error!&quot;);</span>
        }

<span class="fc" id="L208">        int i = 0;</span>
<span class="fc" id="L209">        ctx.setMode(SM4_DECRYPT);</span>
<span class="fc" id="L210">        sm4Setkey(ctx.getSk(), key);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (i = 0; i &lt; 16; i++) {</span>
<span class="fc" id="L212">            swap(ctx.getSk(), i);</span>
        }
<span class="fc" id="L214">    }</span>

    public byte[] sm4CryptEcb(SM4Context ctx, byte[] input) throws SM4Exception, IOException {
<span class="fc" id="L217">        byte[] inputTemp = input;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L219">            throw new SM4Exception(&quot;input is null!&quot;);</span>
        }

<span class="pc bpc" id="L222" title="1 of 4 branches missed.">        if ((ctx.isPadding()) &amp;&amp; (ctx.getMode() == SM4_ENCRYPT)) {</span>
<span class="fc" id="L223">            inputTemp = padding(input, SM4_ENCRYPT);</span>
        }

<span class="fc" id="L226">        int length = inputTemp.length;</span>
<span class="fc" id="L227">        byte[] output = null;</span>
<span class="fc" id="L228">        try (ByteArrayInputStream bins = new ByteArrayInputStream(inputTemp);</span>
<span class="fc" id="L229">             ByteArrayOutputStream bous = new ByteArrayOutputStream()) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            for (; length &gt; 0; length -= 16) {</span>
<span class="fc" id="L231">                byte[] in = new byte[16];</span>
<span class="fc" id="L232">                byte[] out = new byte[16];</span>
<span class="fc" id="L233">                int count = 0;</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                while ((count = bins.read(in)) &gt; 0) {</span>
<span class="fc" id="L235">                    sm4OneRound(ctx.getSk(), in, out);</span>
<span class="fc" id="L236">                    bous.write(out);</span>
                }
            }

<span class="fc" id="L240">            output = bous.toByteArray();</span>
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">            if (ctx.isPadding() &amp;&amp; ctx.getMode() == SM4_DECRYPT) {</span>
<span class="fc" id="L242">                output = padding(output, SM4_DECRYPT);</span>
            }
        }
<span class="fc" id="L245">        return output;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>